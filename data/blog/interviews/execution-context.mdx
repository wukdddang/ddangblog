---
title: 'JavaScript의 실행 컨텍스트에 대해 설명해주세요'
date: 2023-05-16T15:32:14Z
lastmod: '2023-05-10'
tags: ['JavaScript', '면접']
draft: false
summary: '면접 들어가기 전 빠르게 정리하자! JavaScript의 실행 컨텍스트가 무엇인지 질문을 받았다면? 본문과 같이 답변합시다!'
images: ['/static/images/me.jpg']
authors: ['wukddang']
layout: PostLayout
---

안녕하세요! 여기서는 JavaScript의 실행 컨텍스트에 대해 완벽하게 이해하고 넘어가도록 합시다!

<div className="w-80">![comprehension](/static/images/complete-comprehension.jpeg)</div>
본문 내용은 아래 책들과 [제로초님의 블로그](https://www.zerocho.com/category/JavaScript/post/609778ad9f879900043a8728), [ECMAScript 공식문서](https://tc39.es/ecma262/#running-execution-context)를 참고하여
작성하였음을 미리 알려드립니다!{' '}

- [모던 자바스크립트 Deep Dive](http://www.yes24.com/Product/Goods/92742567) {' '}
- [코어 자바스크립트](http://www.yes24.com/Product/Goods/78586788){' '}
- [기초부터 완성까지, 프런트엔드](http://www.yes24.com/Product/Goods/105266398)

## Environment Records

`환경 레코드`라고도 하는 `Environment Records`는 (이하 ER) 현재 실행 컨텍스트와 관련된 코드의 식별자 정보들이 저장(바인딩)됩니다. 

JavaScript 엔진 (이하, JS 엔진) 은 현재 실행 컨텍스트의 코드가 실행되기 이전에 모든 식별자들을 저장하기 때문에 현재 실행중인 컨텍스트에 속한 코드의 변수명들을 모두 알게 되는 셈이 되는 것입니다. 이 과정에서 `호이스팅(hoisting)`이라는 개념이 등장합니다.

호이스팅은, 생성된 실행 컨텍스트의 식별자들을 JS 엔진이 저장하는 과정을 설명하기 위한 `가상의 동작`이라고 보시면 되겠습니다.

일반적으로 ER은

1. `함수 선언문 (function definition)`
2. `블록 스코프 (block scope)`
3. `try, catch 문`

과 같은 JavaScript 코드의 특정 구문 구조와 연결됩니다. 이러한 코드를 평가할 때마다 해당 코드로 생성된 식별자 바인딩을 기록하는 새로운 ER이 만들어집니다. 즉, 위의 JavaScript 코드 구문이 실행될 때 새로운 실행 컨텍스트가 생성되는 것입니다.

이렇게 만들어진 ER에는 상위 렉시컬 스코프를 참조하는 OuterEnv 필드가 존재합니다. 렉시컬 스코프에 대해서는 따로 글을 써보도록 하겠습니다. 간단히 말해서 렉시컬 스코프는, `ER이 결정되는 코드의 범위`라고 보시면 됩니다. 

그러니까 블록 스코프와 함수 스코프에서 실행 컨텍스트가 생성되는 것입니다. 저는 이부분이 조금 헷갈렸는데, ES5 이전의 JavaScript는 함수 스코프만의 렉시컬 스코프만 있었다면, ES6 이후의 JavaScript는 블록 스코프도 렉시컬 스코프로서 동작할 수 있게 되었다는 의미입니다. 와우!

## 실행 컨텍스트 (execution context)

ECMAScript 공식문서에 따르면 실행 컨텍스트의 정의는 다음과 같습니다.

> An execution context is a specification device that is used to track the runtime evaluation of code by an ECMAScript implementation.

쉽게 정의해 보자면, 실행 컨텍스트란 `소스코드를 실행하는 데 필요한 환경 정보들을 모아놓은 객체이며, 코드의 실행 결과를 실제로 관리하는 객체`라고 할 수 있습니다. JavaScript는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅),
외부 환경 정보{' '}를 구성하고, this값을 설정하는 등의 동작을 수행합니다. 함수를 실행하거나, 블록 `{}`을 생성하면 새로운 실행 컨텍스트가 구성됩니다. 실행 컨텍스트는

- `LexicalEnvironment`
- `VariableEnvironment`
- `PrivateEnvironment`

세 가지 컴포넌트로 구성되어 있습니다. ~(LE, VE 각각이 어떤 기능을 하는지, 추가해서 작성할 것)~

`PrivateEnvironment`는 클래스와 관련된 Environment로, 이 글에서는 다루지 않도록 하겠습니다. 가능하다면 다른 글에서 다루도록 하겠습니다.

> - 정보: ES5의 실행 컨텍스트는 thisBinding에 대한 정보를 별도로 저장하였지만, ES6 이후부터는 Environment Records에서 this에 대한 정보를 저장합니다.

그리고 `ECMAScript 공식문서`에서는 `LexicalEnvironment`와 `VariableEnvironment`를 항상 `Environment Records`라고 표현하고 있습니다.

> The LexicalEnvironment and VariableEnvironment components of an execution context are always Environment Records.

JavaScript의 코드는 `콜 스택(call stack`)위에서 동작합니다. 함수를 실행하거나, 블록을 생성하여 구성된 실행 컨텍스트는 바로 이 콜 스택 위에 쌓이게 됩니다. 스택이란 자료구조의 특성에 따라, 스택의 최상단에는 제일 마지막으로 실행된 코드의 실행 컨텍스트가 존재하게 됩니다.

---

함수 스코프, 블록 스코프로 생성되는 실행 컨텍스트를 코드와 함께 이해해봅시다.
먼저 함수 스코프로 이루어진 실행 컨텍스트를 이해해보도록 하겠습니다. 

```js showLineNumbers
var hi = 1
function good() {
  console.log(hi)
  var hi = 3
}
function hello() {
  good()
  console.log(hi)
}
hello()
console.log(hi)
```

JavaScript 코드가 실행되기 전, `전역 실행 컨텍스트`가 콜 스택에 쌓이게 됩니다. 전역 실행 컨텍스트는 브라우저나 Node.js 환경에서 자동적으로 실행되므로 JavaScript 파일이 실행되는 순간 전역 실행 컨텍스트가 활성화 된다고 보시면 됩니다.

<div className="mx-auto w-64">![emptyContext](/static/images/first-context.png)</div>

JavaScript 코드가 실행되기 전에 전역 실행 컨텍스트에는 어떤 식별자들이 저장될까요? 바로 아래 식별자들입니다.
- `var hi`
- `function good() { ... }`
- `function hello() { ... }`

함수 선언문의 경우 var 키워드와 같이 JavaScript 코드 시작 전에 실행 컨텍스트에서 호이스팅 되기 때문에 위와 같은 결과가 나온다고 보시면 되겠습니다. 호이스팅이 마무리되고 나면, JS 엔진은 위에서부터 순차적으로 코드를 읽어갑니다. `var hi`에 `1`을 할당하고, 함수 선언문은 이미 실행 컨텍스트에 저장되어 있으니 지나칩니다.

10번째 줄에서 JS 엔진은 `hello()` 를 실행시킵니다. 여기서, `hello 실행 컨텍스트`가 생성됩니다.


<div className="mx-auto w-64">![emptyContext](/static/images/second-context.png)</div>

hello 실행 컨텍스트를 살펴볼까요? 오, 함수 호출만 2개가 있네요. 이 경우 식별자 저장 없이 JS 엔진은 그저 실행 컨텍스트를 순차적으로 실행합니다. 먼저 `good()` 함수를 실행하죠? 네 맞습니다. `good 실행 컨텍스트`가 생성됩니다.

<div className="mx-auto w-64">![emptyContext](/static/images/third-context.png)</div>

good 실행 컨텍스트를 보면, `console.log(hi)`가 있고, 밑에 `var hi = 3` 이 있네요. `var hi`는 JS 엔진이 실행되기 전에 실행 컨텍스트에 저장됩니다. 정확히는 ER에 저장되죠! 

`console.log(hi)`가 실행될 때, 동일하게 실행 컨텍스트가 생성됩니다. 그러나 호출 외에 다른 기능을 수행하지는 않기에 그림에선 생략했습니다. 😂 호이스팅이 마무리되고 `console.log(hi)`가 실행되면, `hi` 변수는 아직 할당되기 전이기 때문에, `undefined`가 호출됩니다. 여기서 var과 let, const의 차이점이 존재하죠. var은 TDZ(Temporal Dead Zone)가 없습니다. 자세한 건 여기서 봐주세요 ㅎㅎ ([var, let, const의 차이점에 대해 설명해주세요](/blog/interviews/var-let-const))
`hi`에 `3`이 할당되고 나면, good 실행 컨텍스트는 종료됩니다. 그러면 현재는 이런 상황이겠죠?

<div className="mx-auto w-64">![emptyContext](/static/images/second-context.png)</div>

hello 실행 컨텍스트를 봅시다. `good()`함수 호출은 마무리되었고, `console.log(hi)`가 실행되겠네요. 그러면 hi는 무슨 값이 호출될까요? `1`일까요 `3`일까요? 네 당연히 `1`입니다. hello 실행 컨텍스트의 OuterEnv는 전역 실행 컨텍스트이기 때문에, 현재 hello 실행 컨텍스트에 존재하지 않는 변수 hi는 스코프 체이닝에 따라 상위 실행 컨텍스트에서 변수를 찾게 됩니다. 마침 전역 실행 컨텍스트에 변수 `hi`가 있고 이 값을 출력하면 `1`이 나오게 되는 것입니다. ~(스코프 체이닝 설명, OuterEnv 설명)~
`console.log(hi)`가 호출되고 나면, hello 실행 컨텍스트도 콜 스택에서 사라집니다. 이런 상황이죠.

<div className="mx-auto w-64">![emptyContext](/static/images/first-context.png)</div>

마지막으로, `console.log(hi)`가 호출되고, 현재 실행 컨텍스트에서 찾을 수 있는 변수 `hi`의 값을 호출해서 `1`이 출력되게 됩니다. 최종적으로 콜 스택이 전부 비게 되면 JS 엔진의 실행이 종료됩니다.

좀 길긴 한데 생각보다 쉽지 않나요? 🥲🥲 블록 스코프에서 생성되는 실행 컨텍스트도 살펴봅시다!